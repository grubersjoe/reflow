import { traverse } from '@babel/core';
import { parse } from '@babel/parser';
import { File, Comment, Decorator } from '@babel/types';
import prettier, { Options as PrettierOptions } from 'prettier-ts';

import { ReflowOptions } from '..';
import { getParserPlugins } from '../options';

export const BLANK_LINE = /^[ \t]*$/;
export const LINE_BREAK = /\r?\n/;

const BLOCK_COMMENT_AT_BEGINNING_OF_LINE = /^\s*\/\*/;
const LINE_COMMENT_AT_BEGINNING_OF_LINE = /^\s*\/\/.*$/;

// const DECORATOR = /^[ \t]*@.+$/;

const FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;

function parseAst(code: string): File {
  return parse(code, {
    plugins: [...getParserPlugins(), 'flow'],
    sourceType: 'module',
  });
}

function getDecorators(flowAst: File): Decorator[] {
  const decorators: Decorator[] = [];

  traverse(flowAst, {
    enter(path) {
      if (path.isClassDeclaration() && path.node.decorators) {
        decorators.push(...path.node.decorators);
      }
    },
  });

  return decorators;
}

function copyComments(
  tsLines: string[],
  flowLines: string[],
  flowAst: File,
  lineNumber: number,
): string[] {
  const outputLine = tsLines[lineNumber];

  const comment = (flowAst.comments as Comment[]).find(
    comment => comment.loc.start.line - 1 === lineNumber, // lineNumber is zero-based
  );

  if (comment) {
    if (comment.type === 'CommentBlock') {
      if (BLOCK_COMMENT_AT_BEGINNING_OF_LINE.test(flowLines[lineNumber])) {
        `/*${comment.value}*/`
          .split('\n')
          .reverse()
          .forEach(commentLine => {
            tsLines.splice(lineNumber, 0, commentLine);
          });
      } else {
        tsLines[lineNumber] = `${outputLine} /*${comment.value}*/`;
      }
    }

    if (comment.type === 'CommentLine') {
      const lineComment = `//${comment.value}`;

      if (LINE_COMMENT_AT_BEGINNING_OF_LINE.test(flowLines[lineNumber])) {
        tsLines.splice(lineNumber, 0, lineComment);
      } else {
        tsLines[lineNumber] = `${outputLine} ${lineComment}`;
      }
    }
  }

  return tsLines;
}

function getPrettierConfig(overrides?: PrettierOptions): PrettierOptions {
  const defaults: PrettierOptions = {
    parser: 'typescript',
    semi: true,
    singleQuote: true,
    tabWidth: 2,
    trailingComma: 'all',
  };

  return Object.assign({}, defaults, overrides);
}

/**
 * Since Babel uses an *abstract* synax tree, all information about whitespace
 * is lost after parsing. Also Babel's `retainLines` option is not working as
 * expected and will produce broken syntax in some cases. Neither will Prettier
 * help concerning blank lines, because it won't add additional blank lines:
 *
 * https://prettier.io/docs/en/rationale.html#empty-lines
 *
 * Therefore, the following function tries to synchronize the blank lines and
 * comments of two source code fragments. This means: insert blank lines in
 * given code wherever the original code has them and copy all comments from
 * the source to the output. Comments are also handled here, because Babel does
 * not reliably retain their position in the generated code. This approach
 * naively assumes that all code transformations will result in (roughly) the
 * same amount of lines. It's not perfect, but the best I came up with and it
 * seems to work reasonably well in practice.
 */
export function syncBlankLinesAndComments(
  tsCode: string,
  flowCode: Buffer | string,
  pluginOptions: ReflowOptions,
): string {
  // Filter out the Flow directive (@flow)
  const flowLines = String(flowCode)
    .split(LINE_BREAK)
    .filter(line => !FLOW_DIRECTIVE.test(line));

  let tsLines = tsCode.split(LINE_BREAK).filter(line => !BLANK_LINE.test(line));

  const flowAst = parseAst(flowLines.join('\n'));
  const decoratorList = getDecorators(flowAst);

  flowLines.forEach((flowLine, lineNumber) => {
    if (tsLines[lineNumber] === undefined || flowLine === tsLines[lineNumber]) {
      return;
    }

    // Insert an extra blank line if it's present in original file but not in output
    if (BLANK_LINE.test(flowLine)) {
      tsLines.splice(lineNumber, 0, '');
    }

    // Copy comments from original code to TypeScript output
    tsLines = copyComments(tsLines, flowLines, flowAst, lineNumber);

    // Insert blank lines where decorators have been to keep line count
    // consistent for further loop iterations.Each decorator occupies exactly
    // one line after Prettier has been executed with the options used below
    if (pluginOptions.replaceDecorators) {
      const decorator = decoratorList.find(decorator =>
        decorator.loc ? decorator.loc.start.line - 1 === lineNumber : false,
      );

      if (decorator) {
        tsLines.splice(lineNumber, 0, '');
      }
    }
  });

  return tsLines.join('\n');
}

/**
 * Format the code generated by Babel to make it visually as similar as
 * possible to the original code. This is done by executing Prettier multiple
 * times, inserting blank lines and copying comments from the original source
 * to the output.
 */
export function formatOutputCode(
  tsCode: string,
  flowCode: string,
  pluginOptions: ReflowOptions,
): string {
  // The aim of the first Prettier run is to format the original and the output
  // code as similar as possible by forcing consistent line wraps. To do so an
  // infinite printWidth is used and object literals will always be wrapped
  // into multiple lines (even when they would fit in one line).
  const prettierOptions: PrettierOptions = {
    printWidth: Infinity,
    wrapObjects: true,
  };

  flowCode = prettier.format(
    flowCode,
    getPrettierConfig({
      parser: 'babel',
      ...prettierOptions,
    }),
  );

  tsCode = prettier.format(tsCode, getPrettierConfig(prettierOptions));
  tsCode = syncBlankLinesAndComments(tsCode, flowCode, pluginOptions);

  // Run Prettier one more time to iron out any remaining bad formatting.
  tsCode = prettier.format(tsCode, getPrettierConfig());

  return tsCode;
}
